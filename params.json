{
  "name": "Learnembeddedsystem",
  "tagline": "The code and words in the way of learning embedded system",
  "body": "##嵌入式实验一\r\n#### 一 实验目的和要求\r\n* 1 了解嵌入式板卡一般情况；\r\n* 2 熟悉WRTNode的供电等接线方式；\r\n* 3 复习Linux启动过程（操作系统课）；\r\n* 4 复习通过Linux获得硬件数据（操作系统课）\r\n* 5 熟练掌握串口在PC上的使用；\r\n* 6 熟练掌握Linux的以太网和WiFi配置；\r\n* 7 熟练掌握Linux的SSH配置；\r\n* 8 熟练掌握PC上的SSH软件。\r\n* 9 掌握嵌入式板卡和PC建立文件共享的方式；\r\n* 10 寻找和安装交叉编译环境，理解交叉编译；\r\n* 11 熟悉嵌入式板卡的Linux下的编程环境；\r\n* 12 了解远程访问嵌入式板卡图形桌面的方式。  \r\n\r\n#### 二 实验器材\r\n* 1 硬件  \r\n  实验主板一块；  \r\n  5V/1A电源一个；  \r\n  microUSB线一根；  \r\n  USB-TTL串口线一根（FT232RL芯片或PL2303芯片）。  \r\n  以下为自备（可选）器材：  \r\n  PC（Windows/Mac OS/Linux）一台；  \r\n  以太网线一根（可能还需要路由器等）；  \r\n  HDMI显示器；  \r\n  HDMI线；  \r\n  USB键盘/鼠标（无线）；  \r\n  USB Hub，推荐自带供电的类型。  \r\n* 2 软件  \r\n  PC上的USB-TTL串口线配套的驱动程序；  \r\n  PC上的串口终端软件，如minicom、picocom、putty等；  \r\n  PC上的SSH软件，如putty等。  \r\n  交叉编译软件。  \r\n\r\n####三 实验过程和数据记录\r\n* 1 在PC上安装好USB串口驱动和串口终端软件；  \r\n  ![1.1](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346178.png)\r\n  ![1.2](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346217.png)\r\n* 2 按照图纸要求，将USB串口线与WRTnode连接好，并连接好以太网（如果打算采用WiFi，可不连接以太网）。  \r\n  ![1.3](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346259.png)\r\n  ![1.4](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346328.png)\r\n* 3 给WRTnode上电，记录启动过程的输出；  \r\n  启动过程输出：  \r\n```\r\nU-Boot 1.1.3 - Modified by Manfeel (Jul  8 2014 - 18:53:13)\r\n\r\nBoard: Ralink APSoC\r\n\r\n __  __             ______        _\r\n|  \\/  |           |  ____|      | |\r\n| \\  / | __ _ _ __ | |__ ___  ___| |\r\n| |\\/| |/ _` | '_ \\|  __/ _ \\/ _ \\ |\r\n| |  | | (_| | | | | | |  __/  __/ |\r\n|_|  |_|\\__,_|_| |_|_|  \\___|\\___|_|\r\n\r\n//硬件自检\\\r\n//内存大小\r\nDRAM:  64 MB\r\n//代码定位\r\nrelocate_code Pointer at: 83f64000\r\nenable ephy clock...done. rf reg 29 = 5\r\nSSC disabled.\r\nspi_wait_nsec: 28\r\nspi device id: ef 40 18 0 0 (40180000)\r\n//找到存储设备\r\nfind flash: W25Q128FV\r\nraspi_read: from:30000 len:1000\r\n*** Warning - bad CRC, using default environment\r\n============================================\r\n\r\n//UBoot开始引导启动\r\nRalink UBoot Version: 4.1.1.0\r\n--------------------------------------------\r\n//部分硬件基本信息\r\nASIC 7620_MP (Port5<->None)\r\n//内存基本信息\r\nDRAM component: 512 Mbits DDR, width 16\r\nDRAM bus: 16 bit\r\nTotal memory: 64 MBytes\r\nFlash component: SPI Flash\r\nDate:Jul  8 2014  Time:18:53:13\r\n============================================\r\n//CPU基本信息\r\n//缓存信息\r\nicache: sets:512, ways:4, linesz:32 ,total:65536\r\ndcache: sets:256, ways:4, linesz:32 ,total:32768\r\n//频率信息\r\n ##### The CPU freq = 600 MHZ ####\r\n estimate memory size =64 Mbytes\r\nMT7620 gpio init : wps / reset pin\r\nWRTNode LED init.\r\n\r\nPlease choose the operation:\r\n   1: Load system code to SDRAM via TFTP.\r\n   2: Load system code then write to Flash via TFTP.\r\n   3: Boot system code via Flash (default).\r\n   4: Entr boot command line interface.\r\n   7: Load Boot Loader code then write to Flash via Serial.\r\n   9: Load Boot Loader code then write to Flash via TFTP.\r\n\r\nor long press RESET/WPS button to enter web failsafe mode.\r\nbefore LEDON:\r\ndata:3c7f86                                                                   0\r\n//通过Flash启动\r\n3: System Boot system code via Flash.\r\n(Re)start USB...\r\nUSB:   usb_lowlevel_init\r\nMediatek/Ralink USB EHCI host init hccr b01c0000 and hcor b01c0010 hc_length 16\r\nRegister 1111 NbrPorts 1\r\nUSB EHCI 1.00\r\nscanning bus for devices... 1 USB Device(s) found\r\n       scanning bus for storage devices... 0 Storage Device(s) found\r\n//载入linux启动镜像\r\n** Unable to use usb 0:1 for fatload **\r\n## Booting image at 80c00000 ...\r\nBad Magic Number,3FABFA32\r\n## Booting image at bc050000 ...\r\nraspi_read: from:50000 len:40\r\n   Image Name:   MIPS OpenWrt Linux-3.10.44\r\n   Image Type:   MIPS Linux Kernel Image (lzma compressed)\r\n   Data Size:    1029095 Bytes = 1005 kB\r\n   Load Address: 80000000\r\n   Entry Point:  80000000\r\nraspi_read: from:50040 len:fb3e7\r\n   Verifying Checksum ... OK\r\n   Uncompressing Kernel Image ...\r\nhdr->ih_load = 0x00000080\r\ndata pointer = 0x80c00000\r\nfirst 8 bytes data = 8000006D,2F609C00\r\ndata length = 1029095\r\nOK\r\nNo initrd\r\n## Transferring control to Linux (at address 80000000) ...\r\n//引导过程结束，Linux接管控制，开始启动Linux\r\nmanfeel note, bootargs is : root=8:2 rootdelay=5 rootfstype=ext4 rw eth=\"00:11:22:33:44:55\" console=ttyS0,115200\r\n## Giving linux memsize in MB, 64\r\n83f033b0:linux_argv[1] = root=8:2\r\n83f033b9:linux_argv[2] = rootdelay=5\r\n83f033c5:linux_argv[3] = rootfstype=ext4\r\n83f033d5:linux_argv[4] = rw\r\n83f033d8:linux_argv[5] = eth=\"00:11:22:33:44:55\"\r\n83f033f0:linux_argv[6] = console=ttyS0,115200\r\n83f03810:linux_env[0] = memsize=64\r\n83f0381b:linux_env[1] = initrd_start=0x00000000\r\n83f03833:linux_env[2] = initrd_size=0x0\r\n83f03843:linux_env[3] = flash_start=0x00000000\r\n83f0385a:linux_env[4] = flash_size=0x1000000\r\n\r\nStarting kernel ...\r\n//kernel启动过程及日志\r\n[    0.000000] Linux version 3.10.44 (noel@na) (gcc version 4.8.3 (OpenWrt/Linaro GCC 4.8-2014.04 r41508) ) #20 Wed Aug 13 21:00:28 UTC 2014\r\n[    0.000000] Board has DDR2\r\n[    0.000000] Analog PMU set to hw control\r\n[    0.000000] Digital PMU set to hw control\r\n[    0.000000] SoC Type: Ralink MT7620N ver:2 eco:6\r\n[    0.000000] bootconsole [early0] enabled\r\n[    0.000000] CPU revision is: 00019650 (MIPS 24KEc)\r\n[    0.000000] MIPS: machine is WRTNODE\r\n[    0.000000] Determined physical RAM map:\r\n[    0.000000]  memory: 04000000 @ 00000000 (usable)\r\n[    0.000000] Initrd not found or empty - disabling initrd\r\n[    0.000000] Zone ranges:\r\n[    0.000000]   Normal   [mem 0x00000000-0x03ffffff]\r\n[    0.000000] Movable zone start for each node\r\n[    0.000000] Early memory node ranges\r\n[    0.000000]   node   0: [mem 0x00000000-0x03ffffff]\r\n[    0.000000] Primary instruction cache 64kB, VIPT, 4-way, linesize 32 bytes.\r\n[    0.000000] Primary data cache 32kB, 4-way, PIPT, no aliases, linesize 32 bytes\r\n[    0.000000] Built 1 zonelists in Zone order, mobility grouping on.  Total pages: 16256\r\n[    0.000000] Kernel command line: console=ttyS0,115200 rootfstype=squashfs,jffs2\r\n[    0.000000] PID hash table entries: 256 (order: -2, 1024 bytes)\r\n[    0.000000] Dentry cache hash table entries: 8192 (order: 3, 32768 bytes)\r\n[    0.000000] Inode-cache hash table entries: 4096 (order: 2, 16384 bytes)\r\n[    0.000000] Writing ErrCtl register=00003a2b\r\n[    0.000000] Readback ErrCtl register=00003a2b\r\n[    0.000000] Memory: 61652k/65536k available (2317k kernel code, 3884k reserved, 553k data, 200k init, 0k highmem)\r\n[    0.000000] SLUB: HWalign=32, Order=0-3, MinObjects=0, CPUs=1, Nodes=1\r\n[    0.000000] NR_IRQS:256\r\n[    0.000000] CPU Clock: 600MHz\r\n[    0.000000] Calibrating delay loop... 398.13 BogoMIPS (lpj=1990656)\r\n[    0.060000] pid_max: default: 32768 minimum: 301\r\n[    0.060000] Mount-cache hash table entries: 512\r\n[    0.070000] pinctrl core: initialized pinctrl subsystem\r\n[    0.070000] NET: Registered protocol family 16\r\n[    0.090000] bio: create slab <bio-0> at 0\r\n[    0.100000] rt2880_gpio 10000600.gpio: registering 24 gpios\r\n[    0.100000] rt2880_gpio 10000600.gpio: registering 24 irq handlers\r\n[    0.110000] rt2880_gpio 10000638.gpio: registering 16 gpios\r\n[    0.110000] rt2880_gpio 10000638.gpio: registering 16 irq handlers\r\n[    0.120000] rt2880_gpio 10000660.gpio: registering 32 gpios\r\n[    0.120000] rt2880_gpio 10000660.gpio: registering 32 irq handlers\r\n[    0.130000] rt2880_gpio 10000688.gpio: registering 1 gpios\r\n[    0.130000] rt2880_gpio 10000688.gpio: registering 1 irq handlers\r\n[    0.140000] Switching to clocksource MIPS\r\n[    0.140000] NET: Registered protocol family 2\r\n[    0.150000] TCP established hash table entries: 512 (order: 0, 4096 bytes)\r\n[    0.150000] TCP bind hash table entries: 512 (order: -1, 2048 bprocd: Console is alive\r\nprocd: - watchdog -\r\n[    5.120000] usbcore: registered new interface driver usbfs\r\n[    5.120000] usbcore: registered new interface driver hub\r\n[    5.130000] usbcore: registered new device driver usb\r\n[    5.170000] SCSI subsystem initialized\r\n[    5.180000] ehci_hcd: USB 2.0 'Enhanced' Host Controller (EHCI) Driver\r\n[    5.190000] ehci-platform: EHCI generic platform driver\r\n[    5.390000] rt3xxx-usbphy ubsphy.3: remote usb device wakeup disabled\r\n[    5.400000] rt3xxx-usbphy ubsphy.3: UTMI 16bit 30MHz\r\n[    5.400000] ehci-platform 101c0000.ehci: EHCI Host Controller\r\n[    5.410000] ehci-platform 101c0000.ehci: new USB bus registered, assigned bus number 1\r\n[    5.420000] ehci-platform 101c0000.ehci: irq 26, io mem 0x101c0000\r\n[    5.440000] ehci-platform 101c0000.ehci: USB 2.0 started, EHCI 1.00\r\n[    5.440000] hub 1-0:1.0: USB hub found\r\n[    5.450000] hub 1-0:1.0: 1 port detected\r\n[    5.460000] usbcore: registered new interface driver usb-storage\r\nprocd: - preinit -\r\nPress the [f] key and hit [enter] to enter failsafe mode\r\nPress the [1], [2], [3] or [4] key and hit [enter] to select the debug level\r\nkmod: ran 1 iterations\r\n[   10.310000] jffs2: notice: (296) jffs2_build_xattr_subsystem: complete building xattr subsystem, 1 of xdatum (1 unchecked, 0 orphan) and 12 of xref (0 dead, 0 orphan) found.\r\nblock: extroot: no root or overlay mount defined\r\njffs2 is ready\r\njffs2 is ready\r\n[   10.500000] jffs2: notice: (293) jffs2_build_xattr_subsystem: complete building xattr subsystem, 1 of xdatum (1 unchecked, 0 orphan) and 12 of xref (0 dead, 0 orphan) found.\r\nswitching to overlay\r\nprocd: - early -\r\nprocd: - watchdog -\r\nprocd: - ubus -\r\nprocd: - init -\r\nFailed to connect to ubus\r\nPlease press Enter to activate this console.\r\n[   12.380000] NET: Registered protocol family 10\r\n[   12.400000] NTFS driver 2.1.30 [Flags: R/O MODULE].\r\n[   12.450000] nf_conntrack version 0.5.0 (966 buckets, 3864 max)\r\n[   12.480000] ip6_tables: (C) 2000-2006 Netfilter Core Team\r\n[   12.490000] Ralink/MTK WiFi EEPROM API Driver for OpenWrt Trunk. Copyright 2013 lintel<lintel.huang@gmail.com>\r\n[   12.500000] Ralink/MTK WiFi EEPROM API:Installed.\r\n[   12.500000] Ralink/MTK WiFi EEPROM API:SoC is MT7620.\r\n[   13.460000] rt2860v2_ap: module license 'Proprietary' taints kernel.\r\n[   13.470000] Disabling lock debugging due to kernel taint\r\n[   13.520000]\r\n[   13.520000]\r\n[   13.520000] === pAd = c0551000, size = 871592 ===\r\n[   13.520000]\r\n[   13.530000] <-- RTMPAllocTxRxRingMemory, Status=0\r\n[   13.540000] <-- RTMPAllocAdapterBlock, Status=0\r\n[   13.540000] AP Driver version-2.7.1.6\r\n[   13.570000] Linux video capture interface: v2.00\r\n[   13.610000] fuse init (API version 7.22)\r\n[   13.620000] usbcore: registered new interface driver cdc_acm\r\n[   13.630000] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters\r\n[   13.650000] ip_tables: (C) 2000-2006 Netfilter Core Team\r\n[   13.680000] usbcore: registered new interface driver usbserial\r\n[   13.690000] usbcore: registered new interface driver usbserial_generic\r\n[   13.690000] usbserial: USB Serial support registered for generic\r\n[   13.710000] usbcore: registered new interface driver uvcvideo\r\n[   13.710000] USB Video Class driver (1.1.1)\r\n[   13.740000] xt_time: kernel timezone is -0000\r\n[   13.740000] usbcore: registered new interface driver ftdi_sio\r\n[   13.750000] usbserial: USB Serial support registered for FTDI USB Serial Device\r\n[   13.770000] PPP generic driver version 2.4.2\r\n[   13.770000] NET: Registered protocol family 24\r\n[   13.790000] usbcore: registered new interface driver snd-usb-audio\r\n[   17.430000] RtmpOSNetDevDetach(): RtmpOSNetDeviceDetach(), dev->name=ra0!\r\n[   17.960000]\r\n[   17.960000]\r\n[   17.960000] === pAd = c09e3000, size = 871592 ===\r\n[   17.960000]\r\n[   17.970000] <-- RTMPAllocTxRxRingMemory, Status=0\r\n[   17.980000] <-- RTMPAllocAdapterBlock, Status=0\r\n[   17.980000] AP Driver version-2.7.1.6\r\n[   18.000000] RX DESC a2807000  size = 2048\r\n[   18.030000] RTMP_TimerListAdd: add timer obj c0a7aec8!\r\n[   18.030000] RTMP_TimerListAdd: add timer obj c0a44878!\r\n[   18.040000] RTMP_TimerListAdd: add timer obj c0a470c4!\r\n[   18.040000] RTMP_TimerListAdd: add timer obj c0a47184!\r\n[   18.050000] RTMP_TimerListAdd: add timer obj c0a47244!\r\n[   18.050000] RTMP_TimerListAdd: add timer obj c0a47304!\r\n[   18.060000] RTMP_TimerListAdd: add timer obj c0a473c4!\r\n[   18.060000] RTMP_TimerListAdd: add timer obj c0a47484!\r\n[   18.070000] RTMP_TimerListAdd: add timer obj c0a47544!\r\n[   18.070000] RTMP_TimerListAdd: add timer obj c0a47604!\r\n[   18.080000] RTMP_TimerListAdd: add timer obj c0a476c4!\r\n[   18.080000] RTMP_TimerListAdd: add timer obj c0a47784!\r\n[   18.090000] RTMP_TimerListAdd: add timer obj c0a47844!\r\n[   18.090000] RTMP_TimerListAdd: add timer obj c0a47904!\r\n[   18.100000] RTMP_TimerListAdd: add timer obj c0a479c4!\r\n[   18.100000] RTMP_TimerListAdd: add timer obj c0a47a84!\r\n[   18.110000] RTMP_TimerListAdd: add timer obj c0a47b44!\r\n[   18.120000] RTMP_TimerListAdd: add timer obj c0a47c04!\r\n[   18.120000] RTMP_TimerListAdd: add timer obj c0a4484c!\r\n[   18.130000] RTMP_TimerListAdd: add timer obj c0a47098!\r\n[   18.130000] RTMP_TimerListAdd: add timer obj c0a47158!\r\n[   18.140000] RTMP_TimerListAdd: add timer obj c0a47218!\r\n[   18.140000] RTMP_TimerListAdd: add timer obj c0a472d8!\r\n[   18.150000] RTMP_TimerListAdd: add timer obj c0a47398!\r\n[   18.150000] RTMP_TimerListAdd: add timer obj c0a47458!\r\n[   18.160000] RTMP_TimerListAdd: add timer obj c0a47518!\r\n[   18.160000] RTMP_TimerListAdd: add timer obj c0a475d8!\r\n[   18.170000] RTMP_TimerListAdd: add timer obj c0a47698!\r\n[   18.170000] RTMP_TimerListAdd: add timer obj c0a47758!\r\n[   18.180000] RTMP_TimerListAdd: add timer obj c0a47818!\r\n[   18.180000] RTMP_TimerListAdd: add timer obj c0a478d8!\r\n[   18.190000] RTMP_TimerListAdd: add timer obj c0a47998!\r\n[   18.190000] RTMP_TimerListAdd: add timer obj c0a47a58!\r\n[   18.200000] RTMP_TimerListAdd: add timer obj c0a47b18!\r\n[   18.200000] RTMP_TimerListAdd: add timer obj c0a47bd8!\r\n[   18.210000] RTMP_TimerListAdd: add timer obj c0a44820!\r\n[   18.210000] RTMP_TimerListAdd: add timer obj c0a470f0!\r\n[   18.220000] RTMP_TimerListAdd: add timer obj c0a471b0!\r\n[   18.230000] RTMP_TimerListAdd: add timer obj c0a47270!\r\n[   18.230000] RTMP_TimerListAdd: add timer obj c0a47330!\r\n[   18.240000] RTMP_TimerListAdd: add timer obj c0a473f0!\r\n[   18.240000] RTMP_TimerListAdd: add timer obj c0a474b0!\r\n[   18.250000] RTMP_TimerListAdd: add timer obj c0a47570!\r\n[   18.250000] RTMP_TimerListAdd: add timer obj c0a47630!\r\n[   18.260000] RTMP_TimerListAdd: add timer obj c0a476f0!\r\n[   18.260000] RTMP_TimerListAdd: add timer obj c0a477b0!\r\n[   18.270000] RTMP_TimerListAdd: add timer obj c0a47870!\r\n[   18.270000] RTMP_TimerListAdd: add timer obj c0a47930!\r\n[   18.280000] RTMP_TimerListAdd: add timer obj c0a479f0!\r\n[   18.280000] RTMP_TimerListAdd: add timer obj c0a47ab0!\r\n[   18.290000] RTMP_TimerListAdd: add timer obj c0a47b70!\r\n[   18.290000] RTMP_TimerListAdd: add timer obj c0a47c30!\r\n[   18.300000] RTMP_TimerListAdd: add timer obj c09eb1e8!\r\n[   18.300000] RTMP_TimerListAdd: add timer obj c09eaddc!\r\n[   18.310000] RTMP_TimerListAdd: add timer obj c09eb1b8!\r\n[   18.310000] RTMP_TimerListAdd: add timer obj c09eb560!\r\n[   18.320000] RTMP_TimerListAdd: add timer obj c09eb2b0!\r\n[   18.320000] RTMP_TimerListAdd: add timer obj c09eb2e0!\r\n[   18.330000] RTMP_TimerListAdd: add timer obj c09eb4a0!\r\n[   18.340000] RTMP_TimerListAdd: add timer obj c09eb4d0!\r\n[   18.340000] RTMP_TimerListAdd: add timer obj c09ee494!\r\n[   18.350000] RTMP_TimerListAdd: add timer obj c09ee088!\r\n[   18.350000] RTMP_TimerListAdd: add timer obj c09ee464!\r\n[   18.360000] RTMP_TimerListAdd: add timer obj c09ee80c!\r\n[   18.360000] RTMP_TimerListAdd: add timer obj c09ee55c!\r\n[   18.370000] RTMP_TimerListAdd: add timer obj c09ee58c!\r\n[   18.370000] RTMP_TimerListAdd: add timer obj c09ee74c!\r\n[   18.380000] RTMP_TimerListAdd: add timer obj c09ee77c!\r\n[   18.380000] RTMP_TimerListAdd: add timer obj c09f1740!\r\n[   18.390000] RTMP_TimerListAdd: add timer obj c09f1334!\r\n[   18.390000] RTMP_TimerListAdd: add timer obj c09f1710!\r\n[   18.400000] RTMP_TimerListAdd: add timer obj c09f1ab8!\r\n[   18.400000] RTMP_TimerListAdd: add timer obj c09f1808!\r\n[   18.410000] RTMP_TimerListAdd: add timer obj c09f1838!\r\n[   18.410000] RTMP_TimerListAdd: add timer obj c09f19f8!\r\n[   18.420000] RTMP_TimerListAdd: add timer obj c09f1a28!\r\n[   18.420000] RTMP_TimerListAdd: add timer obj c09f49ec!\r\n[   18.430000] RTMP_TimerListAdd: add timer obj c09f45e0!\r\n[   18.440000] RTMP_TimerListAdd: add timer obj c09f49bc!\r\n[   18.440000] RTMP_TimerListAdd: add timer obj c09f4d64!\r\n[   18.450000] RTMP_TimerListAdd: add timer obj c09f4ab4!\r\n[   18.450000] RTMP_TimerListAdd: add timer obj c09f4ae4!\r\n[   18.460000] RTMP_TimerListAdd: add timer obj c09f4ca4!\r\n[   18.460000] RTMP_TimerListAdd: add timer obj c09f4cd4!\r\n[   18.470000] RTMP_TimerListAdd: add timer obj c09f7c98!\r\n[   18.470000] RTMP_TimerListAdd: add timer obj c09f788c!\r\n[   18.480000] RTMP_TimerListAdd: add timer obj c09f7c68!\r\n[   18.480000] RTMP_TimerListAdd: add timer obj c09f8010!\r\n[   18.490000] RTMP_TimerListAdd: add timer obj c09f7d60!\r\n[   18.490000] RTMP_TimerListAdd: add timer obj c09f7d90!\r\n[   18.500000] RTMP_TimerListAdd: add timer obj c09f7f50!\r\n[   18.500000] RTMP_TimerListAdd: add timer obj c09f7f80!\r\n[   18.510000] RTMP_TimerListAdd: add timer obj c09faf44!\r\n[   18.510000] RTMP_TimerListAdd: add timer obj c09fab38!\r\n[   18.520000] RTMP_TimerListAdd: add timer obj c09faf14!\r\n[   18.520000] RTMP_TimerListAdd: add timer obj c09fb2bc!\r\n[   18.530000] RTMP_TimerListAdd: add timer obj c09fb00c!\r\n[   18.530000] RTMP_TimerListAdd: add timer obj c09fb03c!\r\n[   18.540000] RTMP_TimerListAdd: add timer obj c09fb1fc!\r\n[   18.550000] RTMP_TimerListAdd: add timer obj c09fb22c!\r\n[   18.550000] RTMP_TimerListAdd: add timer obj c09fe1f0!\r\n[   18.560000] RTMP_TimerListAdd: add timer obj c09fdde4!\r\n[   18.560000] RTMP_TimerListAdd: add timer obj c09fe1c0!\r\n[   18.570000] RTMP_TimerListAdd: add timer obj c09fe568!\r\n[   18.570000] RTMP_TimerListAdd: add timer obj c09fe2b8!\r\n[   18.580000] RTMP_TimerListAdd: add timer obj c09fe2e8!\r\n[   18.580000] RTMP_TimerListAdd: add timer obj c09fe4a8!\r\n[   18.590000] RTMP_TimerListAdd: add timer obj c09fe4d8!\r\n[   18.590000] RTMP_TimerListAdd: add timer obj c0a0149c!\r\n[   18.600000] RTMP_TimerListAdd: add timer obj c0a01090!\r\n[   18.600000] RTMP_TimerListAdd: add timer obj c0a0146c!\r\n[   18.610000] RTMP_TimerListAdd: add timer obj c0a01814!\r\n[   18.610000] RTMP_TimerListAdd: add timer obj c0a01564!\r\n[   18.620000] RTMP_TimerListAdd: add timer obj c0a01594!\r\n[   18.620000] RTMP_TimerListAdd: add timer obj c0a01754!\r\n[   18.630000] RTMP_TimerListAdd: add timer obj c0a01784!\r\n[   18.630000] RTMP_TimerListAdd: add timer obj c0a46c7c!\r\n[   18.640000] RTMP_TimerListAdd: add timer obj c0a46870!\r\n[   18.650000] RTMP_TimerListAdd: add timer obj c0a46c4c!\r\n[   18.650000] RTMP_TimerListAdd: add timer obj c0a46ff4!\r\n[   18.660000] RTMP_TimerListAdd: add timer obj c0a46d44!\r\n[   18.660000] RTMP_TimerListAdd: add timer obj c0a46d74!\r\n[   18.670000] RTMP_TimerListAdd: add timer obj c0a46cac!\r\n[   18.670000] RTMP_TimerListAdd: add timer obj c0a46cdc!\r\n[   18.680000] RTMP_TimerListAdd: add timer obj c0a46d0c!\r\n[   18.680000] RTMP_TimerListAdd: add timer obj c0a51834!\r\n[   18.690000] RTMP_TimerListAdd: add timer obj c0a51950!\r\n[   18.690000] RTMP_TimerListAdd: add timer obj c0a51860!\r\n[   18.700000] RTMP_TimerListAdd: add timer obj c0a48dac!\r\n[   18.700000] RTMP_TimerListAdd: add timer obj c09e8668!\r\n[   18.710000] RTMP_TimerListAdd: add timer obj c09eb914!\r\n[   18.720000] RTMP_TimerListAdd: add timer obj c09eebc0!\r\n[   18.720000] RTMP_TimerListAdd: add timer obj c09f1e6c!\r\n[   18.730000] RTMP_TimerListAdd: add timer obj c09f5118!\r\n[   18.730000] RTMP_TimerListAdd: add timer obj c09f83c4!\r\n[   18.740000] RTMP_TimerListAdd: add timer obj c09fb670!\r\n[   18.740000] RTMP_TimerListAdd: add timer obj c09fe91c!\r\n[   18.750000] RTMP_TimerListAdd: add timer obj c0a48ac0!\r\n[   18.750000] RTMP_TimerListAdd: add timer obj c0a48e14!\r\n[   18.890000] APSDCapable[0]=0\r\n[   18.900000] APSDCapable[1]=0\r\n[   18.900000] APSDCapable[2]=0\r\n[   18.900000] APSDCapable[3]=0\r\n[   18.900000] APSDCapable[4]=0\r\n[   18.910000] APSDCapable[5]=0\r\n[   18.910000] APSDCapable[6]=0\r\n[   18.910000] APSDCapable[7]=0\r\n[   18.920000] APSDCapable[8]=0\r\n[   18.920000] APSDCapable[9]=0\r\n[   18.920000] APSDCapable[10]=0\r\n[   18.930000] APSDCapable[11]=0\r\n[   18.930000] APSDCapable[12]=0\r\n[   18.930000] APSDCapable[13]=0\r\n[   18.930000] APSDCapable[14]=0\r\n[   18.940000] APSDCapable[15]=0\r\n[   18.940000] default ApCliAPSDCapable[0]=0\r\n[   19.140000] Key1Str is Invalid key length(0) or Type(0)\r\n[   19.150000] Key2Str is Invalid key length(0) or Type(0)\r\n[   19.160000] Key3Str is Invalid key length(0) or Type(0)\r\n[   19.160000] Key4Str is Invalid key length(0) or Type(0)\r\n[   19.370000] 7c:2f:8f:4a:a4:6f:7c:85:e0:29:d3:aa:5e:6c:cc:ed:\r\n[   19.380000] 59:62:18:ab:2c:82:d3:45:aa:43:0a:b1:6a:40:59:ca:\r\n[   19.380000]\r\n[   19.380000] I/F(apcli0) Key1Str is Invalid key length!\r\n[   19.420000] 1. Phy Mode = 9\r\n[   19.420000] 2. Phy Mode = 9\r\n[   19.430000] EEPROM:Read from [factory] offset 0x0,length 0x200.\r\n[   19.510000] E2PROM: D0 target power=0xff20\r\n[   19.510000] E2PROM: 40 MW Power Delta= 0\r\n[   19.520000] 3. Phy Mode = 9\r\n[   19.520000] RTMP_TimerListAdd: add timer obj c09e8260!\r\n[   19.530000] AntCfgInit: primary/secondary ant 0/1\r\nInitialize RF Central Registers for E2 !!!\r\n[   19.540000] Initialize RF Central Registers for E3 !!!\r\n[   19.540000] Initialize RF Channel Registers for E2 !!!\r\n[   19.550000] Initialize RF Channel Registers for E3 !!!\r\n[   19.550000] Initialize RF DCCal Registers for E2 !!!\r\n[   19.560000] Initialize RF DCCal Registers for E3 !!!\r\n[   19.560000] D1 = 0, D2 = 7, CalCode = 16 !!!\r\n[   19.570000] RT6352_Temperature_Init : BBPR49 = 0x0\r\n[   19.570000] RT6352_Temperature_Init : TemperatureRef25C = 0xfffffff6\r\n[   19.580000] Current Temperature from BBP_R49=0xfffffff8\r\n[   19.590000] RT6352_TssiTableAdjust: upper_bound = 0x7F decimal: 127\r\n[   19.590000] RT6352_TssiTableAdjust: lower_bound = 0xFFFFFF80 decimal: -128\r\n[   19.600000] *** RT6352_TssiTableAdjust: G Tssi[-7 .. +7] = -128 -1 -1 -1 -128 -1 -1\r\n[   19.600000]  - -1 - -1 -1 -1 -1 -1 -1 -1, offset=-10, tuning=0\r\n[   19.610000] RT6352_TssiTableAdjust: G Tssi[-7 .. +7] = -128 -11 -11 -11 -128 -11 -11 - -11 - -11 -11 -11 -11 -11 -11 -11, offset=-10, tuning=0\r\n[   19.630000] mp_temperature=0xffffffff, step = +7\r\n[   19.630000] E2PROM: G Tssi[-7 .. +7] = -128 -11 -11 -11 -128 -11 -11 - -11 - -11 -11 -11 -11 -11 -11 -11, offset=-10, tuning=0\r\n[   19.650000]  TX BW Filter Calibration !!!\r\n[   19.770000]  RX BW Filter Calibration !!!\r\n[   20.010000] LOFT Calibration Done!\r\n[   20.010000] IQCalibration Start!\r\n[   20.030000] IQCalibration Done! CH = 0, (gain= 0, phase= 1)\r\n[   20.030000] IQCalibration Start!\r\n[   20.050000] IQCalibration Done! CH = 1, (gain= 0, phase= 2)\r\n[   20.050000] TX IQ Calibration Done!\r\n[   20.090000] internal ALC is not enabled in NVM !\r\n[   20.100000] bAutoTxAgcG = 0\r\n[   20.100000] MCS Set = ff ff 00 00 01\r\n[   20.170000] Main bssid = 64:51:7e:80:17:ce\r\n[   20.180000] <==== rt28xx_init, Status=0\r\n[   20.350000] 0x1300 = 00064380\r\n[   20.930000] device eth0.1 entered promiscuous mode\r\n[   20.940000] device eth0 entered promiscuous mode\r\n[   20.950000] br-lan: port 1(eth0.1) entered forwarding state\r\n[   20.950000] br-lan: port 1(eth0.1) entered forwarding state\r\n[   21.900000] device ra0 entered promiscuous mode\r\n[   21.910000] br-lan: port 2(ra0) entered forwarding state\r\n[   21.910000] br-lan: port 2(ra0) entered forwarding state\r\n[   22.950000] br-lan: port 1(eth0.1) entered forwarding state\r\n[   23.910000] br-lan: port 2(ra0) entered forwarding state\r\nprocd: - init complete -\r\n```\r\n* 4 从终端登陆WRTnode的Linux，配置网络和/或WiFi，从WRTnode和PC两端证明网络已连接；  \r\n  ![1.5](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346368.png)\r\n  ![1.6](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346417.png)\r\n* 5 配置WRTnode的SSH，可尝试采用各种不同的认证方式；  \r\n  WRTnode的SSH在初始化的时候已经自动配置。  \r\n* 6 从PC通过SSH登陆WRTnode；  \r\n  ![1.7](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346481.png)\r\n* 7 看到多个不同端口的登陆（本机键盘/屏幕、串口和SSH），并运用Linux的write来互相通信。  \r\n  WRTnode上的linux属于精简版linux，没有找到查看当前在线用户的相关命令。如果安装nmap套件，剩余空间不足。  \r\n* 8 配置嵌入式板卡上的SAMBA客户端，使它能访问PC上共享的目录；  \r\n  ![1.8](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346535.png)\r\n* 9 尝试各种与嵌入式板卡传递文件的方式并做比较：  \r\n  Sftp传输测试：  \r\n  ![1.9](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346597.png)\r\n  在传输大文件时，有时会卡住无法继续传输，传输速度尚可。  \r\n  SSH传输测试：  \r\n  传输较稳定，速度平均为128KB/s。  \r\n* 10 选择和安装PC上的交叉编译环境；  \r\n  在linux下，下载WRTnode帮助页面中提供的SDK，配置$PATH与$STAGING_DIR:  \r\n```\r\nexport PATH=\"/home/lincoln/WRTnode_sdk/toolchain/bin:$PATH\"\r\nexport STAGING_DIR=\"/home/lincoln/WRTnode_sdk/toolchain/bin:$STAGING_DIR\"\r\n```\r\n\r\n![1.10](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346656.png)\r\n* 11 交叉编译C语言的浮点运算程序到WRTnode上去运行，证明所编译的程序是MIPS的；  \r\n  程序运行结果：  \r\n  ![1.11](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346695.png)\r\n  程序源代码：  \r\n  ![1.12](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/14657334675.png)\r\n  十六进制查看：  \r\n  ![1.13](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146573346803.png)\r\n  从000012b0位置可以看到，链接的库是mips的，因此此段程序应当是mips程序。同时，在WRTnode上能够运行，因此应当是mips程序。  \r\n* 12 尝试嵌入式板卡上的三个语言的开发环境：C/C++、Python和Java；\r\n  WRTnode板卡上没有找到上述语言的开发环境，只能通过交叉编译运行。\r\n* 13 尝试一种从PC远程访问嵌入式板卡图形桌面的方式：x-window（通过SSH）、RDP或VNC。\r\n  WRTnode暂无支持的图形桌面。  \r\n#### 四 讨论与心得  \r\n通过这次的实验，我对于嵌入式开发有了一个从无到有的认识，虽然目前还只是初步的学习，不过已经了解了开发板与开发机之间的通信、文件传输、交叉编译等知识。不过由于我分配到的是WRTnode，这块板子以轻量化著称，因此也牺牲了许多其他的功能，比如说各种各样的编译器。同时，由于WRTnode上的存储空间较小（64Mb），除去操作系统等必要组件之后，剩余的空间已经很小了，因此也不太可能把安装各种各样的开发环境。这样也会导致基于WRTnode开发程序相对困难一些。\r\n\r\n##嵌入式实验三  \r\n#### 一 实验目的和要求  \r\n* 1 理解MCU上电启动过程；  \r\n* 2 掌握使用Cube库来编写STM32裸机程序的方法；  \r\n* 3 掌握使用Cube库来编写GPIO和UART程序的方法；  \r\n* 4掌握使用Cube库来编写中断响应程序的方法；  \r\n* 5理解前后台程序模式；  \r\n* 6掌握在STM32F103上编写裸机程序并下载运行的方法。  \r\n\r\n#### 二 实验器材  \r\n* 1 硬件  \r\n  STM32F103核心板板一块；  \r\n  microUSB线一根（供电）；  \r\n  STLink板或USB串口板一块。  \r\n* 2 软件  \r\n  交叉编译软件。  \r\n\r\n#### 三 实验过程和数据记录  \r\n* 1 编写Cube程序，配置UART1为9600,8n1，上电后向串口输出“Hello”，在PC上通过串口软件观察结果.  \r\n  ![2.1](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305527.png)\r\n* 2 通过面包板在PA11和PA12各连接一个按钮开关到地；  \r\n  ![2.2](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/14657430559.png)\r\n* 3 编写Cube程序，配置PA11和PA12为内部上拉到输入模式，在main()函数循环检测PA11按钮按下，并在按钮按下时 在串口输出“Pressed”  \r\n  ![2.3](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305631.png)\r\n* 4 编写Cube程序，配置PA12下降沿触发中断，程序中设置两个全局变量，一个为计数器，一个为标识。当中断触发 时，计数器加1，并设置标识。在主循环中判断标识，如果标识置位则清除标识并通过串口输出计数值；  \r\n  ![2.4](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305666.png)\r\n* 5 编写Cube程序，开启定时器为200ms中断一次，中断触发时设置标识，主循环根据这个标识来做串口输出（取消4 的串口输出）;  \r\n  ![2.5](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305704.png)\r\n* 6 编写完整的码表程序，PA12的按钮表示车轮转了一圈，通过计数器可以得到里程，通过定时器中断得到的时间可以计算出速度；PA11的按钮切换模式，模式一在串口输出里程，模式二在串口输出速度。  \r\n* 7 PA11的按钮也采用中断方式检测，主程序只检测标识做串口发送；  \r\n* 8 在主循环中加入休眠，由定时器中断退出休眠；  \r\n* 9 串口发送采用中断模式，由定时器中断程序启动串口发送，发送遇到字符串结尾停止；主程序在配置完成后始终休眠。  \r\n  ![2.6](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305744.png)  \r\n\r\n#### 四 代码分析：  \r\n* Main函数部分:  \r\n  主要完成UART、GPIO、TIMER的初始化、输出欢迎信息，以及主循环。  \r\n  ![2.7](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305786.png)\r\n* 时钟与GPIO中断处理函数：  \r\n  ![2.8](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305825.png)\r\n* 时钟与GPIO中断回调函数：  \r\n  ![2.9](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305863.png)\r\n* 辅助函数：  \r\n  ![2.10](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305897.png)\r\n* Num2str函数负责将数字转化为字符串，printResult负责根据目前状态输出结果  \r\n  ![2.11](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574305978.png)  \r\n\r\n##嵌入式实验四\r\n#### 一 实验目的和要求\r\n1.1 理解uboot等bootloader的一般功能和基本工作原理；  \r\n1.2掌握在STM32F103上编写裸机程序并下载运行的方法。  \r\n#### 二 实验器材  \r\n2.1 硬件  \r\n* STM32F103核心板板一块；  \r\n* microUSB线一根（供电）；  \r\n* STLink板或USB串口板一块。  \r\n  2.2 软件  \r\n* 交叉编译软件。  \r\n#### 三 实验过程和数据记录  \r\n* 写一个自己的简易bootloader，能通过串口执行两条最简单的指令：  \r\n  * peek addr 以一个字为单位读取内存中 addr 位置的数据(addr是4字节对齐,十六进制的 形式,长度为8位十六进制,例如 0x00008000),并以十六进制的形式输出  \r\n  * poke addr data 以一个字为单位修改内存中 addr 位置的数据为 data(addr 是 4 字节对齐,十六进制的形式,长度为 8位十六进制, data 也是十六进制的形式,长度为8位十六进制)  \r\n* 程序执行结果:  \r\n  ![4.1](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351494.png)\r\n  从执行结果可以看出，开机时显示欢迎信息，输入命令  \r\n  Peek 0x08000000，显示出了相应内存地址的内容  \r\n  Peek 0x20000000，显示出了相应内存地址的内容  \r\n  Poke 0x20000000 0x1111FFFF，首先显示了在没有修改之前的内容，之后显示出了写入之后的内存结果。  \r\n\r\n* 代码分析：  \r\n  * 功能函数  \r\n    ![4.2](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351549.png)\r\n    sendData函数对DMA的串口发送功能进行了简单的包装。  \r\n    receiveData函数对DMA串口的接收功能进行了简单的包装。  \r\n    parseOrder进行命令的解析。  \r\n    parseAddr进行十六进制字符串到数字的转换。  \r\n  * 主函数  \r\n    ![4.3](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351598.png)\r\n    主函数中负责输出开始的欢迎信息，在主循环中进行命令的接收、解析以及执行，在传输中，使用了DMA进行信息的发送和接收。  \r\n  * DMA及串口的配置函数  \r\n    * 配置函数：  \r\n      ![4.4](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351653.png)\r\n    * 析构函数：  \r\n      ![4.5](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351692.png)\r\n    * 中断函数  \r\n      ![4.6](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351725.png)\r\n  * 来自于官方文档的头文件  \r\n    ![4.7](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351759.png)\r\n\r\n* 下载配置  \r\n  Bootloader需要配置相应的启动地址，以及可写的内存范围，从而之后装载程序并开始执行，配置如下：  \r\n  ![4.8](http://cfgwu.img48.wal8.com/img48/549504_20160612201041/146574351801.png)\r\n  可以看到，rom地址从0x08000000开始，长度为0x10000，ram地址从0x20000000开始，长度为0x5000。  \r\n\r\n##嵌入式实验五  \r\n#### 一 实验目的和要求  \r\n* 学习uC/OS II的应用程序编写；  \r\n* 理解如何直接操纵GPIO，体会与Linux的不同；  \r\n* 学习单总线设备的访问方式；  \r\n* 学习7段数码管的时分复用驱动方式。  \r\n\r\n#### 二 实验器材  \r\n  STM32F103板一块；  \r\n  USB串口板一块；  \r\n  面包板一块；  \r\n  两位7段数码管（共阳）一颗；  \r\n  360Ω 1/8W电阻2颗；  \r\n  DHT-11 温湿度传感器1个；  \r\n  面包线若干。  \r\n\r\n#### 三 实验过程和数据记录\r\n* 设计输出方案，画连线示意图；  \r\n* 在面包板上连线，完成外部电路；  \r\n* 编写C/C++程序，测试程序和电路；  \r\n  * 测试、实现uC/OS II对GPIO的访问；  \r\n  * 实现DHT-11数据的读；  \r\n  * 实现以时分复用方式在四位7段数码管上依次显示0000-9999的数字；  \r\n  * 用两个uc/OS II任务，一个定时读DHT-11数据，一个轮流驱动数码管，一秒一次显示当前温度和湿度。注意处理好 两个任务之间的数据共享。  \r\n    程序执行结果:  \r\n\r\n从执行结果可以看出DHT11电源指示灯亮起，右侧的绿色led灯熄灭（熄灭表示数据校验通过），左侧的4位数码管前两位表示湿度，百分制，后两位表示温度。从之前读取到的数据来看，小数部分全部都是0，因此忽略。  \r\n\r\n* 代码分析：  \r\n  * uCOS移植  \r\n    os_cpu.h 注释掉uCOS自身关于时钟处理的函数，之后会在stm32的时钟中断中直接实现。  \r\n\r\nos_cpu_a.asm 对底层汇编做一些修改，主要是由于汇编标准不同的缘故。  \r\n\r\nos_cpu_c.c 注释掉一些与之前注释的系统时钟相关的宏定义。  \r\n\r\nos_cfg.h 内核裁剪。  \r\n\r\nstm32f1xx_it.c 配置操作系统时钟中断。  \r\n\r\nstartup_stm32f103xb.s 把stm32的pendSV中断连接到操作系统上去。  \r\n\r\n\t* 用户代码\r\nincludes.h 用户函数的头文件集合。  \r\n\r\napp_cfg.h 用户函数堆栈、优先级定义。  \r\n\r\napp.h 用户函数定义。  \r\n\r\napp.c 用户函数。  \r\n\r\n由于在操作系统中，中断的响应会导致操作系统的中断嵌套，因此会产生中断的资源需要在操作系统启动之后、相关任务启动之前配置。Task_start是初始任务，DHT11_Display负责温湿度传感器数据在数码管上的显示。同时，DHT11的数据读取需要至少精确到20us左右的时间控制，如果使用操作系统自身的时钟或者是任务切换，都不能保证实时性，因此，我使用外部定时器中断来控制数据的读取。  \r\n\r\n\t* main.c 操作系统启动，中断响应函数，资源配置函数。  \r\n\r\nmain函数负责做初始的资源配置，例如系统时钟等，然后初始化系统，创建第一个任务，启动操作系统。  \r\n\r\nTIM_Init函数配置外置定时器，GPIO_Init函数配置两个GPIO口，由于不会产生中断，因此可以在操作系统启动前配置。  \r\n\r\nDisplay_Init函数初始化数码管使用到的GPIO口，DHT11_output与DHT11_input控制DHT11数据口的属性，在数据读取中会使用到。  \r\n\r\n定时器回调函数负责读取DHT11的数据。  \r\n\r\nstm32f1xx_it.c  \r\n\r\n配置外部定时器的中断处理函数，使其进入操作系统的中断嵌套。  \r\n\r\n##嵌入式实验六  \r\n#### 一 实验目的和要求  \r\n* 学习Linux内核的配置和编译；  \r\n* 深入理解Linux系统调用；  \r\n* 理解ARM和x86的CPU模式（系统模式、用户模式等）的不同。  \r\n#### 二 实验器材  \r\n* 硬件  \r\n  pcDuino v2板一块；  \r\n  5V/1A电源一个；  \r\n  microUSB线一根；  \r\n  以下为自备（可选）器材：  \r\n  PC（Windows/Mac OS/Linux）一台；  \r\n  USB-TTL串口线一根（FT232RL芯片或PL2303芯片）；  \r\n  以太网线一根（可能还需要路由器等）。  \r\n* 软件  \r\n  交叉编译软件。  \r\n#### 三 实验过程和数据记录  \r\n* 实验步骤  \r\n  * 使用交叉编译工具或本机编译工具，通过Linux内核源码进行实验:  \r\n  * 寻找、下载pcDuino的Linux内核源码；  \r\n  * 在内核中加入新的系统调用，具体功能没有要求，能输出调试信息即可;  \r\n  * 修改内核代码配置，编译内核；  \r\n  * 将编译好的内核装载到pcDuino启动；  \r\n  * 编写C代码，用两种方法做系统调用，测试：  \r\n  * 嵌入汇编代码，用r0传参数；  \r\n\r\n* 实验过程记录  \r\n  * 从git上下载树莓派相关的linux源代码与编译工具  \r\n\r\n  * 修改内核源代码，添加系统调用  \r\n    在/arch/arm/kernel/call.S中添加系统跳转位置  \r\n\r\n在这里，我们把新的系统调用添加到最后面，位于第403行。  \r\n\r\n在/arch/arm/include/uapi/asm/unistd.h中设置新增系统调用的位置（即该系统调用在系统调用表中的位置）  \r\n\r\n我们将新增的系统调用添加在第420行。  \r\n\r\n在源代码中添加新的系统调用的实现函数：  \r\n\r\n可以看到新增的系统调用仅仅是在系统日志中打印被调用的信息。  \r\n\r\n最后，在/include/linux/syscall.h中添加新增的系统调用的声明。  \r\n\r\n新增系统调用的定义被添加在892行。  \r\n\r\n编译系统并装入sd卡中  \r\n\r\n验证新增的系统调用  \r\n\r\n编写以下用户程序，分别使用c语言syscall函数和汇编代码调用新增的系统调用。  \r\n\r\n使用syscall函数调用直接将调用号以及相关的参数作为syscall的参数即可。使用汇编调用则是将系统调用号放在r7寄存器上，将参数放在r0及之后的寄存器中。需要注意的是，对于较大的立即数，mov可能会无法通过汇编，使用ldr即可。  \r\n编译运行之后，可以在系统日志中看到如下输出：  \r\n\r\n可见新增的系统调用已经被成功调用。  \r\n\r\n与x86相比，添加系统调用的步骤都是相同的，不同之处在于具体文件的位置不同，以及设计到与汇编相关的系统调用表的修改，由于不同的平台汇编代码格式的不同，因此这部分的代码区别较大。  \r\n\r\n##嵌入式系统七  \r\n####一 实验目的和要求  \r\n* 学习嵌入式Linux的GPIO的使用方式；  \r\n* 学习嵌入式Linux的Arduino接口库；  \r\n* 学习使用面包板搭简单的外部电路；  \r\n* 学习Linux设备驱动程序的开发过程。  \r\n* 学习在内核中访问外设寄存器，操纵外设的方法。  \r\n####二 实验器材  \r\n* 硬件  \r\n  Linux实验板卡一块；  \r\n  5V/1A电源一个；  \r\n  microUSB线一根；  \r\n  面包板一块；  \r\n  MAX7219驱动的8x8 LED矩阵一个；  \r\n  面包线若干。  \r\n  以下为自备（可选）器材：  \r\n  PC（Windows/Mac OS/Linux）一台；  \r\n  USB-TTL串口线一根（FT232RL芯片或PL2303芯片）；  \r\n  以太网线一根（可能还需要路由器等）。\r\n* 软件\r\n  编译软件；\r\n  Fritzing。\r\n####三 实验过程和数据记录  \r\n首先将led矩阵显示器与树莓派连接，使用5v供电，然后将data、cs、clk分别接到没有使用的gpio口上:  \r\n\r\n编写设备驱动程序：  \r\n相关定义：  \r\n\r\nData_pin表示数据gpio的接口号  \r\nClk_pin表示时钟gpio的接口号  \r\nCs_pin表示片选gpio的接口号  \r\nDECODE_MOD、INTENSITY、SCAN_LIMIT、SHUTDOWN、DISPLAY_TEST分别是led显示矩阵的功能寄存器地址  \r\nBUFFERSIZE是字符设备缓冲区的大小  \r\n相关结构：  \r\n\r\n驱动相关函数（更多部分请参看LEDdriver.c）  \r\n\r\n编写makefile文件（交叉编译）：  \r\n\r\n编写驱动测试程序：  \r\n\r\n可以看到，在打开文件的时候，使用的是非阻塞的方式，因此写入之后函数将会马上返回，而写入的字符将会在驱动程序的缓冲区中，每500ms显示一个字符。  \r\n装载驱动，运行测试程序，运行过程请见视频:  \r\n视频地址：http://v.youku.com/v_show/id_XMTU5MTAzOTY5Ng==.html  \r\n密码：3134113  \r\n\r\n##嵌入式系统实验八  \r\n#### 一 实验目的和要求  \r\n* 复习socket编程（网络原理课）；  \r\n* 实现一个网络访问的LED矩阵显示器。  \r\n#### 二 实验器材  \r\n* 硬件  \r\n  Linux实验板卡一块；  \r\n  5V/1A电源一个；  \r\n  microUSB线一根；  \r\n  面包板一块；  \r\n  8x8 LED矩阵一块；  \r\n  74HC595两个；  \r\n  360Ω 1/8W电阻8颗；  \r\n  面包线若干。  \r\n  以下为自备（可选）器材：  \r\n  PC（Windows/Mac OS/Linux）一台；  \r\n  USB-TTL串口线一根（FT232RL芯片或PL2303芯片）；  \r\n  以太网线一根（可能还需要路由器等）。  \r\n* 软件  \r\n  编译软件。  \r\n#### 三 实验过程  \r\n* 设计外部设备方案，画连线示意图；  \r\n* 在面包板上连线，完成外部电路；  \r\n* 编写Linux应用程序，能通过第七次实验的设备驱动程序控制LED矩阵显示字符串，每个字符停留500ms；  \r\n* 编写Linux应用程序，能通过TCP接受一个连接，将发来的文字在LED矩阵上流动显示出来；  \r\n* 用telnet连接Linux板卡，发送字符串来显示。  \r\n#### 四 代码分析  \r\nTelnetserver代码如下：  \r\n\r\n代码中使用多线程来对矩阵显示器进行写入，主线程监听tcp连接，接收数据之后写入同步的queue中，同时子线程监听queue，当有数据到达时，就将其写入矩阵显示器中。退出命令为“ExIT”，当客户端输入ExIT时，子线程将会退出，主线程在收到子线程退出的信息之后也会退出。  \r\n#### 五 实验结果  \r\n实验过程视频请见：  \r\nhttp://v.youku.com/v_show/id_XMTYwMDE3NTgxMg==.html\r\n密码：  \r\n3134113\r\n",
  "google": "",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}